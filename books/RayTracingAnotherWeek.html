<meta charset="utf-8">
<!-- Markdeep: https://casual-effects.com/markdeep/ -->



                                   **Ray Tracing: Another Week**
                                           Trevor David Black
                                     Version 0.0.1, 2019-Dec-18
                         <br>Copyright 2019. Trevor David Black. All rights reserved.



Overview
====================================================================================================


Affine Transforms
====================================================================================================

<div class='together'>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class rect : public hittable {
        public:
            rect() {}
            rect(material* mat_ptr) : mp(mat_ptr) {}

            virtual bool hit(const ray& r, double t0, double t1, hit_record& rec) const;
            virtual bool bounding_box(double t0, double t1, aabb& output_box) const;

            material  *mp;
    };

    bool rect::bounding_box(double t0, double t1, aabb& output_box) const {
        output_box = aabb(vec3(-0.5, -0.0001, 0.5), vec3(0.5, 0.0001, 0.5));
        return true;
    }

    bool rect::hit(const ray& r, double t0, double t1, hit_record& rec) const {
        auto t = -r.origin().y() / r.direction().y();
        if (t < t0 || t > t1)
            return false;
        auto x = r.origin().x() + t*r.direction().x();
        auto z = r.origin().z() + t*r.direction().z();
        if (x < -0.5 || x > 0.5 || z < -0.5 || z > 0.5)
            return false;
        rec.u = x + 0.5;
        rec.v = z + 0.5;
        rec.t = t;
        rec.mat_ptr = mp;
        rec.p = r.at(t);
        rec.normal = vec3(0, 1, 0);
        return true;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [rect-class]: <kbd>[aarect.h]</kbd> Simplifying our rects to a single class]
</div>


<div class='together'>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    vec3 ray_color(const ray& r, hittable *world, int depth) {
        hit_record rec;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        if (depth <= 0 || !world->hit(r, 0.001, infinity, rec))
        {
            vec3 unit_direction = unit_vector(r.direction());
            auto t = 0.5*(unit_direction.y() + 1.0);
            return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        ray scattered;
        vec3 attenuation;
        vec3 emitted = rec.mat_ptr->emitted(rec.u, rec.v, rec.p);
        if (!rec.mat_ptr->scatter(r, rec, attenuation, scattered))
            return emitted;

        return emitted + attenuation * ray_color(scattered, world, depth-1);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [adding-skyline]: <kbd>[main.cc]</kbd> Adding skyline back in]
</div>


<div class='together'>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    hittable **list = new hittable*[1];
    material *red = new lambertian(new constant_texture(vec3(0.85, 0.05, 0.05)));
    list[0] = new rect(red);
    hittable *world = new hittable_list(list, 1);

    vec3 lookfrom(0, 2, 2);
    vec3 lookat(0, 0, 0);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [single-rect-main]: <kbd>[main.cc]</kbd> Depicting a single red rect]

  ![Single Red Rect](../images/img.single-rect.png)

</div>

<div class='together'>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include <iostream>

    class vec4 {
        public:
            vec4() : e{0,0,0,0} {}
            vec4(double e0, double e1, double e2, double e3) : e{e0, e1, e2, e3} {}

            double x() const { return e[0]; }
            double y() const { return e[1]; }
            double z() const { return e[2]; }
            double w() const { return e[3]; }

            vec4 operator-() const { return vec4(-e[0], -e[1], -e[2], -e[3]); }
            double operator[](int i) const { return e[i]; }
            double& operator[](int i) { return e[i]; }

            vec4& operator+=(const vec4 &v) {
                e[0] += v.e[0];
                e[1] += v.e[1];
                e[2] += v.e[2];
                e[3] += v.e[3];
                return *this;
            }

            vec4& operator*=(const double t) {
                e[0] *= t;
                e[1] *= t;
                e[2] *= t;
                e[3] *= t;
                return *this;
            }

            vec4& operator/=(const double t) {
                return *this *= 1/t;
            }

            double length() const {
                return sqrt(length_squared());
            }

            double length_squared() const {
                return e[0]*e[0] + e[1]*e[1] + e[2]*e[2] + e[3]*e[3];
            }

            inline static vec4 random() {
                return vec4(random_double(), random_double(), random_double(), random_double());
            }

            inline static vec4 random(double min, double max) {
                return vec4(random_double(min, max),
                            random_double(min, max),
                            random_double(min, max),
                            random_double(min, max));
            }

            double e[4];
    };


    // vec4 Utility Functions

    inline std::ostream& operator<<(std::ostream &out, const vec4 &v) {
        return out << v.e[0] << ' ' << v.e[1] << ' ' << v.e[2] << ' ' << v.e[3];
    }

    inline vec4 operator+(const vec4 &u, const vec4 &v) {
        return vec4(u.e[0] + v.e[0], u.e[1] + v.e[1], u.e[2] + v.e[2], u.e[3] + v.e[3]);
    }

    inline vec4 operator-(const vec4 &u, const vec4 &v) {
        return vec4(u.e[0] - v.e[0], u.e[1] - v.e[1], u.e[2] - v.e[2], u.e[3] - v.e[3]);
    }

    inline vec4 operator*(const vec4 &u, const vec4 &v) {
        return vec4(u.e[0] * v.e[0], u.e[1] * v.e[1], u.e[2] * v.e[2], u.e[3] * v.e[3]);
    }

    inline vec4 operator*(double t, const vec4 &v) {
        return vec4(t*v.e[0], t*v.e[1], t*v.e[2], t*v.e[3]);
    }

    inline vec4 operator*(const vec4 &v, double t) {
        return t * v;
    }

    inline vec4 operator/(vec4 v, double t) {
        return (1/t) * v;
    }

    inline double dot(const vec4 &u, const vec4 &v) {
        return u.e[0] * v.e[0]
             + u.e[1] * v.e[1]
             + u.e[2] * v.e[2]
             + u.e[3] * v.e[3];
    }

    inline vec4 unit_vector(vec4 v) {
        return v / v.length();
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [vec4-class]: <kbd>[vec4.h]</kbd> Building a vec4 class]
</div>

<div class='together'>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "vec4.h"

    class mat4x4 {
        public:
            mat4x4() {
                v[0] = vec4(1, 0, 0, 0);
                v[1] = vec4(0, 1, 0, 0);
                v[2] = vec4(0, 0, 1, 0);
                v[3] = vec4(0, 0, 0, 1);
            }

            mat4x4(const vec4 &v0, const vec4 &v1, const vec4 &v2, const vec4 &v3) {
               v[0] = v0;
               v[1] = v1;
               v[2] = v2;
               v[3] = v3;
            }

            mat4x4(double m00, double m01, double m02, double m03,
                   double m10, double m11, double m12, double m13,
                   double m20, double m21, double m22, double m23,
                   double m30, double m31, double m32, double m33) {
               v[0] = vec4(m00, m01, m02, m03);
               v[1] = vec4(m10, m11, m12, m13);
               v[2] = vec4(m20, m21, m22, m23);
               v[3] = vec4(m30, m31, m32, m33);
            }

            vec4 v[4];
    };

    inline vec4 operator*(const mat4x4 &m, const vec4 &v) {
        return vec4(dot(m.v[0], v),
                    dot(m.v[1], v),
                    dot(m.v[2], v),
                    dot(m.v[3], v));
    }

    inline mat4x4 operator*(const mat4x4 &a, const mat4x4 &b) {
        vec4 bt0 = vec4(b.v[0].e[0], b.v[1].e[0], b.v[2].e[0], b.v[3].e[0]);
        vec4 bt1 = vec4(b.v[0].e[1], b.v[1].e[1], b.v[2].e[1], b.v[3].e[1]);
        vec4 bt2 = vec4(b.v[0].e[2], b.v[1].e[2], b.v[2].e[2], b.v[3].e[2]);
        vec4 bt3 = vec4(b.v[0].e[3], b.v[1].e[3], b.v[2].e[3], b.v[3].e[3]);

        return mat4x4(dot(a.v[0], bt0), dot(a.v[0], bt1), dot(a.v[0], bt2), dot(a.v[0], bt3),
                      dot(a.v[1], bt0), dot(a.v[1], bt1), dot(a.v[1], bt2), dot(a.v[1], bt3),
                      dot(a.v[2], bt0), dot(a.v[2], bt1), dot(a.v[2], bt2), dot(a.v[2], bt3),
                      dot(a.v[3], bt0), dot(a.v[3], bt1), dot(a.v[3], bt2), dot(a.v[3], bt3));
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [mat4x4-class]: <kbd>[mat4x4.h]</kbd> The simplest mat4x4 class]
</div>

<div class='together'>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class srt {
        public:
            srt() {}
            srt(double sx, double sy, double sz,
                double rx, double ry, double rz,
                double tx, double ty, double tz)
            {
                mat4x4 scale = scale_matrix(sx, sy, sz);
                mat4x4 rot_x = rotation_x_matrix(rx);
                mat4x4 rot_y = rotation_y_matrix(ry);
                mat4x4 rot_z = rotation_z_matrix(rz);
                mat4x4 trans = translation_matrix(tx, ty, tz);

                m = scale * rot_x * rot_y * rot_z * trans;
            }


            mat4x4 m;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [srt-class]: <kbd>[srt.h]</kbd> The simplest Scale-Rotation-Translation class]
</div>


<div class='together'>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "srt.h"

    ...

    class hittable {
    public:
        virtual bool hit(const ray& r, double t_min, double t_max, hit_record& rec) const = 0;
        virtual bool bounding_box(double t0, double t1, aabb& output_box) const = 0;

        srt* transform;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [hittable-with-srt]: <kbd>[hittable.h]</kbd> Adding an SRT transform to hittable]
</div>


<div class='together'>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class rect : public hittable {
        public:
            rect() {}
            rect(material* mat_ptr) : mp(mat_ptr) {}
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            rect(material* mat_ptr, srt* srt0) : mp(mat_ptr) {
                transform = srt0; 
            }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            virtual bool hit(const ray& r, double t0, double t1, hit_record& rec) const;
            virtual bool bounding_box(double t0, double t1, aabb& output_box) const;

            material  *mp;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [rect-srt-constructor]: <kbd>[aarect.h]</kbd> Adding an SRT constructor to rect]
</div>





<div class='together'>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    hittable **list = new hittable*[1];
    material *red = new lambertian(new constant_texture(vec3(0.85, 0.05, 0.05)));
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
    list[0] = new rect(red, new srt());
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    hittable *world = new hittable_list(list, 1);

    vec3 lookfrom(0, 2, 2);
    vec3 lookat(0, 0, 0);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [srt-rect]: <kbd>[main.cc]</kbd> A single rect with initial srt]

If everything went correctly, you should get the same picture as before.

</div>




<div class='together'>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class srt {
        public:
            srt() {}
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            srt(double sx, double sy, double sz,
                double rx, double ry, double rz,
                double tx, double ty, double tz)
            {
                mat4x4 scale = scale_matrix(sx, sy, sz);
                mat4x4 rot_x = rotation_x_matrix(rx);
                mat4x4 rot_y = rotation_y_matrix(ry);
                mat4x4 rot_z = rotation_z_matrix(rz);
                mat4x4 trans = translation_matrix(tx, ty, tz);

                m = scale * rot_x * rot_y * rot_z * trans;
            }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            mat4x4 m;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [srt-class-parameters]: <kbd>[srt.h]</kbd> The srt class with valued constructor]
</div>


<!-- Markdeep: https://casual-effects.com/markdeep/ -->
<link rel='stylesheet' href='../style/book.css'>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep.min.js"></script>
<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
